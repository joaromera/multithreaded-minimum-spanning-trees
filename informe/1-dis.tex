\section{Desarrollo}

\subsection{Estructuras}

\subsubsection{Thread}
\begin{verbatim}
struct Thread{
    Grafo agm;
    ColaDePrioridad ejesVecinos;
    pthread_mutex_t fusion_req;   
    pthread_mutex_t fusion_ack;   
    pthread_mutex_t fusion_ready; 
};
\end{verbatim}

  Trabajamos con esta estructura para resguardar la información de cada thread. La misma consiste de un grafo que será el agm parcial del thread, una cola de prioridad que contiene a los ejes cuyo nodo destino es alcanzable desde el agm y tres mutex para administrar las fusiones. Tendremos un vector global que contendrá uno de estos structs por cada thread. El nombre del mismo es threadData.
  
\subsubsection{Colores}
\begin{verbatim}
class Colores {

    vector<int> _colores;
    vector<pthread_mutex_t> _locks;
};
\end{verbatim}
Para controlar que thread es dueño de cada nodo utilizamos esta estructura que contiene un vector con el color de cada uno, los cuales no son otra cosa que los thread id. Para evitar race condition e incongruencias cada nodo tiene además un mutex asociado el cual nos va a permitir tener acceso exclusivo al mismo . Vamos a distinguir además a los nodos libres con un -1.  Las operaciones principales de la clase son esDueño que nos permite conocer al thread que posee a ese nodo y capturarNodo cuyo objetivo es convertir a un thread en dueño de un nodo. En caso de que esto ultimo no sea posible porque ya pertenece a otro thread se puede solicitar una fusión. Cuando esta se produzca los nodos del thread de mayor id de los involucrados cambiaran de dueño y pasaran a ser del ganador. 

\subsubsection{Fusión}

Como dijimos cada thread cuenta con tres mutex para administrar tanto la solicitud como la entrada de fusiones. En cada ciclo los threads van a chequear si tienen funciones entrantes haciendo trylock de su mutex fusion\_req. Mientras no puedan tomarlo implica que otro thread esta esperando para fusionarse. De ser así hace un unlock de su fusion\_ack despertando al thread solicitante y un lock de fusion\_ready. Esto ultimo es para esperar a que el otro thread termine de realizar fusión. Una vez que ya no tiene pendientes procede a buscar al próximo nodo e intentar capturarlo. En caso de que pertenezca a otro thread solicita una fusión de la siguiente forma: Primero chequea que no tenga funciones entrantes haciendo un trylock de su fusion\_req. Esto lo hacemos para evitar un posible deadlock. Luego lo mismo pero con el fusion\_req del thread dueño del nodo que quiere capturar. Si puede conseguirlo hace lock del fusion\_ack del otro thread quedando así en espera hasta que el mismo este preparado para realizar la fusión. Una vez que la misma se produce se verifica que el dueño siga siendo el mismo ya que podría haber ocurrido una fusión y por lo tanto haber cambiado. Si se mantuvo se debe chequear cual es el de menor id que será el que "sobreviva". El otro sera reiniciado y comenzará de cero. El sobreviviente tendrá ahora la unión de los agm y las colas de prioridad. Por ultimo ambos fusion\_req serán desbloqueados y así como el fusion\_ready del perdedor. Es importante remarcar que el thread reiniciado mantiene el estado de sus mutex ya que sino podría ocurrir que algún thread quede colgado esperando fusionarse con el. Si no hubiera sido posible conseguir alguno de los fusion\_req o el dueño del nodo hubiera cambiado el thread habría vuelto al principio del ciclo.

\subsection{Algoritmo}
\begin{algorithm}
\begin{algorithmic}
\caption{mstParaleloThread}
\Function{mstParalelothread}{grafo}
\STATE $my\_id \gets thread\_counter++ $
\STATE $eje\_actual$
\STATE $my\_data \gets threadData[my\_id]$
\WHILE{$true$}
\STATE $thread\_attend\_fusion\_requests(my\_id)$
\STATE $my\_data.fusion\_req.unlock()$
\STATE $status \gets buscarNodo(my\_id,ejeActual)$
\IF{($status = noHayNodosDisponibles$)}
\STATE $thread\_attend\_fusion\_requests(my\_id)$
\ENDIF
\IF{($status = agmCompleto$)}
\STATE $break$
\ENDIF
\STATE $owner\_id \gets colores.capturarNodo(ejeActual.nodoDestino,my$\textunderscore$id)$
\IF{($my\_id = owner\_id$)}
\STATE $my\_data.insertarEje(ejeActual)$
\STATE $my\_data.agregarEjesVecinos(g,ejeActual.nodoDestino)$
\ELSE 
\STATE $owner\_data \gets threadData[owner\_id]$
\IF{($my\_data.fusion\_req.trylock() \neq 0 )$}
\STATE $continue$
\ENDIF
\IF{($owner\_data.fusion\_req.trylock() \neq 0$)}
\STATE $my\_data.fusion\_req.unlock()$
\STATE $continue$
\ENDIF
\STATE $owner\_data.fusion\_ack.lock()$
\IF{($colores.esDueno(ejeActual,owner\_id)$)}
\STATE $my\_data.agm.insertarEje(ejeActual)$
\IF{($my\_id < owner\_id $)}
\STATE $fuse(my\_id,owner\_id)$
\ELSE
\STATE $fuse(owner\_id,my\_id)$
\ENDIF
\ENDIF
\ENDIF
\STATE $owner\_id.fusion\_req.unlock()$
\STATE $my\_id.fusion\_req.unlock()$
\STATE $owner\_id.fusion\_ready.unlock()$
\ENDWHILE
\end{algorithmic}
\end{algorithm}


\newpage
Aclaraciones:
\begin{itemize}
    \item No realizamos copias del threadData en la implementación. Esto es solamente para clarificar el pseudocódigo.
    \item $thread\_attend\_fusion\_requests$ realiza el chequeo de las funciones entrantes como se explica en la sección 2.1.3.
    \item La idea de buscarNodo es que encuentre el próximo nodo a agregar al agm del thread. Si aun no tiene ninguno toma el primero libre que encuentre. Sino al nodo alcanzable cuyo eje es de peso mínimo. Además de devolver un status retorna el eje en ejeActual.
\end{itemize}
