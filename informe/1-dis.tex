\section{Desarrollo}

\subsection{Estructuras}

\subsubsection{Thread}
\begin{verbatim}
struct Thread{
    Grafo agm;
    ColaDePrioridad ejesVecinos;
    pthread_mutex_t fusion_req;   
    pthread_mutex_t fusion_ack;   
    pthread_mutex_t fusion_ready; 
};
\end{verbatim}

 Trabajamos con esta estructura para resguardar la información de cada thread. La misma consiste de un grafo que será el agm parcial del thread, una cola de prioridad que contiene a los ejes cuyo nodo destino es alcanzable desde el agm y tres mutex para administrar las fusiones. Tendremos un vector global que contendrá uno de estos structs por cada thread. El nombre del mismo es threadData.



\subsubsection{Colores}
\begin{verbatim}
class Colores {

    vector<int> _colores;
    vector<pthread_mutex_t> _locks;
};
\end{verbatim}
Para controlar que thread es dueño de cada nodo utilizamos esta estructura que contiene un vector con el color de cada uno, los cuales no son otra cosa que los thread id. Para evitar race condition e incongruencias cada nodo tiene además un mutex asociado que utilizaremos tanto para conocer a su dueño como para cambiarlo. 

\subsubsection{Fusión}

Como dijimos cada thread cuenta con tres mutex para administrar tanto la solicitud como la entrada de fusiones. En cada ciclo los threads van a chequear si tienen funciones entrantes haciendo trylock de su mutex fusion$\textunderscore$req. Mientras no puedan tomarlo implica que otro thread esta esperando para fusionarse. De ser así hace un unlock de su fusion$\textunderscore$ack despertando al thread solicitante y un lock de fusion$\textunderscore$ready. Esto ultimo es para esperar a que el otro thread termine de fusionarse. Una vez que ya no tiene pendientes procede a buscar al próximo nodo. En caso de que pertenezca a otro thread solicita una fusión de la siguiente forma: Primero chequea que no tenga funciones entrantes haciendo un trylock de su fusion$\textunderscore$req. Esto lo hacemos para evitar deadlock. Luego lo mismo pero con el fusion$\textunderscore$req del thread dueño del nodo que quiere conseguir. Si puede conseguirlo hace lock del fusion$\textunderscore$ack del otro thread quedando así en espera hasta que el mismo este preparado para realizar la fusión. Una vez que la misma se produce se vuelve a chequear al dueño del nodo ya que podría haber ocurrido una fusión y por lo tanto no ser el mismo. Si se mantuvo se debe chequear cual es el de menor id que será el que "sobreviva". El otro sera reiniciado y comenzará de cero. El sobreviviente tendrá ahora la unión de los agm y las colas de prioridad. Por ultimo ambos fusion$\textunderscore$req serán desbloqueados y así como el fusion$\textunderscore$ready del perdedor. Es importante remarcar que el thread reiniciado mantiene el estado de sus mutex ya que sino podría ocurrir que algún thread quede colgado esperando fusionarse. Si no hubiera sido posible conseguir alguno de los fusion$\textunderscore$req o el dueño del nodo hubiera cambiado el thread habría vuelto al principio del ciclo.

\subsection{Algoritmo}
\begin{algorithm}
\begin{algorithmic}
\caption{mstParaleloThread}
\Function{mstParaleloThread}{grafo}

\STATE $my$\textunderscore$id \gets thread$\textunderscore$counter++ $
\STATE $eje$\textunderscore$actual$
\STATE $my$\textunderscore$data \gets threadData[my$\textunderscore$id]$
\WHILE{$true$}
\STATE $thread$\textunderscore$attend$\textunderscore$fusion$\textunderscore$requests(my$\textunderscore$id)$
\STATE $my$\textunderscore$data.fusion$\textunderscore$req.unlock()$
\STATE $status \gets buscarNodo(my$\textunderscore$id,ejeActual)$
\IF{($status = noHayNodosDisponibles$)}
\STATE $thread$\textunderscore$attend$\textunderscore$fusion$\textunderscore$requests(my$\textunderscore$id)$
\ENDIF
\IF{($status = agmCompleto$)}
\STATE $break$
\ENDIF
\STATE $owner$\textunderscore$id \gets colores.capturarNodo(ejeActual.nodoDestino,my$\textunderscore$id)$
\IF{($my$\textunderscore$id = owner$\textunderscore$id$)}
\STATE $my$\textunderscore$data.insertarEje(ejeActual)$
\STATE $my$\textunderscore$data.agregarEjesVecinos(g,ejeActual.nodoDestino)$
\ELSE 
\STATE $owner$\textunderscore$data \gets threadData[owner$\textunderscore$id]$
\IF{($my$\textunderscore$data.fusion$\textunderscore$req.trylock() \neq 0 )$}
\STATE $continue$
\ENDIF
\IF{($owner$\textunderscore$data.fusion$\textunderscore$req.trylock() \neq 0$)}
\STATE $my$\textunderscore$data.fusion$\textunderscore$req.unlock()$
\STATE $continue$
\ENDIF
\STATE $owner$\textunderscore$data.fusion$\textunderscore$ack.lock()$
\IF{($colores.esDueño(ejeActual,owner$\textunderscore$id)$)}
\STATE $my$\textunderscore$data.agm.insertarEje(ejeActual)$
\IF{($my$\textunderscore$id < owner$\textunderscore$id $)}
\STATE $fuse(my$\textunderscore$id,owner$\textunderscore$id)$
\ELSE
\STATE $fuse(owner$\textunderscore$id,my$\textunderscore$id)$
\ENDIF
\ENDIF
\ENDIF
\STATE $owner$\textunderscore$id.fusion$\textunderscore$req.unlock()$
\STATE $my$\textunderscore$id.fusion$\textunderscore$req.unlock()$
\STATE $owner$\textunderscore$id.fusion$\textunderscore$ready.unlock()$
\ENDWHILE
\end{algorithmic}
\end{algorithm}


\newpage
Aclaraciones:

\begin{itemize}
    \item No realizamos copias del threadData en la implementación. Esto es solamente para clarificar el pseudocódigo
\end{itemize}
