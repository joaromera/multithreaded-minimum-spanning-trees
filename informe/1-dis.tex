\subsection{Cuadrados}

\subsubsection{Descripción}

\begin{center}
	\includegraphics[width=0.5\textwidth]{imagenes/ncfom-cuadrados.jpg}
\end{center}

Esta operación genera un efecto \textit{geométrico}, borrando curvas y generando un efecto de \textit{cuadrados}. Esto se logra reemplazando cada píxel por el máximo en un cuadrado con vértice en dicho píxel.
\[cuadrado(p) = \underset{0\leq i \leq 3, 0 \leq j \leq 3}{\max} A[p_0+i][p_1+j] \]

\subsubsection{Implementación ASM}

En este filtro procesamos de a 4 píxeles: tenemos dos ciclos, uno que recorre las columnas de la imagen y otro que recorre las filas. A continuación el pseudocódigo de la implementación \textit{SIMD}:

\begin{itemize}

\item Primero se arma el stack frame y se guardan en los registros de propósito general las entradas. (Líneas 30 a 45)
\item Luego se dibuja el borde negro de 4 píxeles con el llamado a la función auxiliar \textit{CompletarConCeros} en la línea 52.
\item Antes de comenzar el ciclo se limpian los registros usados para evitar errores. (Líneas 62 a 70)
\item Se setea el comienzo de las imágenes fuente y de destino luego del borde negro, y se trae de memoria la máscara a usar. (Líneas 72 a 77)
\item Iniciamos los índices de columnas, filas y offset a usar para los ciclos del algoritmo. (Líneas 80 a 91)
\item Condiciones de los ciclos de filas y columnas: si la fila llegó al final, saltar al final del ciclo de filas, y análogo con las columnas.
\item El cuerpo del ciclo principal del filtro es donde se realiza el proceso del filtro. En los registros XMM se carga la matriz desde la memoria.
\end{itemize}

\begin{codesnippet}
  \begin{verbatim}
	103		;Loading 4x4 matrix on XMM registers.
	104		movdqu first_row, [src]
	105		movdqu second_row, [src+src_row_size]
	106		movdqu third_row, [src+src_row_size*2]
	107		movdqu fourth_row, [src+fourth_row_offset]
  \end{verbatim}
\end{codesnippet}

\begin{center}
  \begin{tabular}{|c || c || c || c |}
  \hline
  $row1[0]$ & $row1[1]$ & $row1[2]$ & $row1[3]$ \\ \hline
  \end{tabular}
  \\ \textbf{XMM0 $\gets$ row1}
\end{center}
\begin{center}
  \begin{tabular}{|c || c || c || c |}
  \hline
  $row2[0]$ & $row2[1]$ & $row2[2]$ & $row2[3]$ \\ \hline
  \end{tabular}
  \\ \textbf{XMM1 $\gets$ row2}
\end{center}
\begin{center}
  \begin{tabular}{|c || c || c || c |}
  \hline
  $row3[0]$ & $row3[1]$ & $row3[2]$ & $row3[3]$ \\ \hline
  \end{tabular}
  \\ \textbf{XMM2 $\gets$ row3}
\end{center}
\begin{center}
  \begin{tabular}{|c || c || c || c |}
  \hline
  $row4[0]$ & $row4[1]$ & $row4[2]$ & $row4[3]$ \\ \hline
  \end{tabular}
  \\ \textbf{XMM3 $\gets$ row4}
\end{center}

\begin{itemize}
\item Una vez que el algoritmo carga la matriz en los registros XMM0-XMM3, aplica el algoritmo para hallar el máximo. Este se encontrara en la parte baja del registro XMM4, y se copia a memoria en la imagen de destino.
\end{itemize}

\begin{codesnippet}
  \begin{verbatim}
	;Find maximums and store in the vector_maximum register.
	110		jmp .hallarMaximos

	112		.retornarDeMaximos:
			;Save maximums on the destination image.
	114		movss [dst], vector_maximum
  \end{verbatim}
\end{codesnippet}

\begin{itemize}
\item Al final de estas cuatro comparaciones, el vector maximum tendrá en cada píxel, el máximo de su correspondiente columna.
\end{itemize}

\begin{codesnippet}
  \begin{verbatim}
			;Algorithm for finding maximums:
	137		.hallarMaximos:
	138		pxor vector_maximum, vector_maximum

			;Find maximum comparing row by row on each column.
	141		pmaxub vector_maximum, first_row
	142		pmaxub vector_maximum, second_row
	143		pmaxub vector_maximum, third_row
	144		pmaxub vector_maximum, fourth_row
  \end{verbatim}
\end{codesnippet}

\begin{center}
  \begin{tabular}{|c || c || c || c |}
  \hline
  $max(Column1)$ & $max(Column2)$ & $max(Column3)$ & $max(Column4)$ \\ \hline
  \end{tabular}
  \\ \textbf{vector_maximum (XMM4)}
\end{center}

\begin{itemize}
\item Se rota el vector de máximos 3 veces y se hacen tres comparaciones, para obtener el máximo general de la matriz:
\end{itemize}

\begin{codesnippet}
  \begin{verbatim}
	146		movdqu rotated_vector_maximum, vector_maximum

	;Rotate vector one píxel to the right and compare.
	;Repeat four times to find the maximum among all píxels in the vector.
	150		pshufb rotated_vector_maximum, mask
	151		pmaxub vector_maximum, rotated_vector_maximum
	152		pshufb rotated_vector_maximum, mask
	153		pmaxub vector_maximum, rotated_vector_maximum
	154		pshufb rotated_vector_maximum, mask
	155		pmaxub vector_maximum, rotated_vector_maximum
	156		jmp .retornarDeMaximos
  \end{verbatim}
\end{codesnippet}

\begin{center}
  \begin{tabular}{|c || c || c || c |}
  \hline
   $max(Column2)$ & $max(Column3)$ & $max(Column4)$ & $max(Column1)$\\ \hline
  \end{tabular}
  \\ \textbf{rotated_vector_maximum (XMM6)}
\end{center}
\begin{center}
    \begin{tabular}{|c || c || c || c |}
  \hline
  $...$ & $...$ & $...$ & $max(Column4, Column1)$ \\ \hline
  \end{tabular}
  \\ \textbf{vector_maximum (XMM4)}
\end{center}
\begin{center}
  \begin{tabular}{|c || c || c || c |}
  \hline
    $max(Column3)$ & $max(Column4)$ & $max(Column1)$ & $max(Column2)$\\ \hline
  \end{tabular}
  \\ \textbf{rotated_vector_maximum (XMM6)}

\end{center}
\begin{center}
  \begin{tabular}{|c || c || c || c |}
  \hline
  $...$ & $...$ & $...$ & $max(Column4, Column1, Column2)$ \\ \hline
  \end{tabular}
  \\ \textbf{vector_maximum (XMM4)}
\end{center}
\begin{center}
  \begin{tabular}{|c || c || c || c |}
  \hline
  $max(Column4)$ & $max(Column1)$ & $max(Column2)$ & $max(Column3)$ \\ \hline
  \end{tabular}
  \\ \textbf{rotated_vector_maximum (XMM6)}
\end{center}
\begin{center}
      \begin{tabular}{|c || c || c || c |}
  \hline
  $...$ & $...$ & $...$ & $max$ \\ \hline
  \end{tabular}
  \\ \textbf{vector_maximum (XMM4)}
\end{center}

\begin{itemize}
\item De la línea 117 a la 134 se obtienen los próximos píxeles a procesar y cómo pasar a la siguiente fila cuando es necesario.
\item Para terminar, se desarma el stack frame.
\end{itemize}
